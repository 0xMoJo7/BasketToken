# BasketToken

`BasketToken` is a naive implementation of [Set Protocol&#39;s](https://github.com/SetProtocol/set-protocol-v2) `SetToken` and `BasicIssuanceModule`.

BasketToken allows users to create a new ERC20 token as a &quot;basket&quot; or &quot;set&quot; of underlying ERC20&#39;s. The user decides how many units of the underlying ERC20&#39;s must be transferred into the contract in order to mint a BasketTon.

## Contracts

The protocol consists of 3 contracts:

- `BasketToken.sol` is the ERC20 token, based on Set Protocol&#39;s `SetToken`, this is the architecture for BasketToken, containing the constructor that is interacted with in the next contract.
  
- `BasketCreator.sol` is a factory contract for generating and deploying BasketTokens. New BasketToken creators provide the components (underlying ERC20s), units (how many units of the ERC20s are required per BasketToken), a name for the BasketToken and finally a symbol to the `create()` function to generate a new BasketToken.
  
- `BasketBroker.sol` is the contract for interacting with a specific BasketToken instance. This contract handles the issuing of the BasketToken in exchange for the underlying ERC20&#39;s as well as the redeeming of BasketTokens in exchange for the underlying ERC20&#39;s (This portion of the contract is based on Set Protocol&#39;s [BasicIssuanceModule](https://github.com/SetProtocol/set-protocol-v2/blob/master/contracts/protocol/modules/BasicIssuanceModule.sol). In addition to the issuing/redemption of BasketTokens, this contract also handles the lottery and pot fee incorporated with the BasketToken. This contract is specific to each BasketToken. The constructor takes the BasketToken address as a parameter as well [the necessary Chainlink variables](https://docs.chain.link/docs/vrf-contracts/) for the VRFConsumer Oracle.
  

## Lottery + Pot Fees

The twist behind this implementation of BasketToken is that when you redeem your BasketToken back for the underlying ERC20 components, 5% of the BasketToken is not burned, but held in reserve for a lottery.

Each time a user mints BasketTokens, a mapping keeps track of a balance of how many BasketTokens an address holds. The balance is also reduced as users redeem their BasketTokens. This means user&#39;s who own more BasketTokens are more likely to win the lottery when it is drawn.

Any user may call the `imFeelingLucky()` function in a specific `BasketBroker` contract to kick off the lottery, however, there is only a 30% chance the lottery takes place. The 30% is calculated by using a random number generated by Chainlink&#39;s [VRFConsumer](https://github.com/daiquilibrium/daiquilibrium-protocol/blob/master/protocol/contracts/lottery/chainlink/VRFConsumerBase.sol). The formula for this is `(randomNum % 10) + 1` which provides a number between 1-10. If the number is &lt;= 3, the lottery takes places. The user can check if the lottery occured by viewing the Events on Etherscan, or seeing if the contract distibuted BasketTokens in the latest tx.

If the lottery takes place, the lottery tickets array is populated based on the amount of BasketTokens per address. The lottery tickets array is then shuffled using Fisher-Yates algorithm based on the same random number used to calculate the lottery chance. The user with their address in the first position of the array after the shuffle will be transferred the accrued pot fees from prior BasketToken redemption pot fees.

## Deploying with HardHat

In the `scripts` directory there are examples of how to deploy and interact with the contracts via `ethers.js`. All of these examples take place on the Rinkeby testnet, but could be tweaked for mainnet or other testnets. For these examples, it is necessary to have two private keys in the `.env` file and configured in `hardhat.config.js` (they also need to have Rinkeby Ether in order to cover gas of the transactions).

If you simply want to deploy the contracts, and test the issuing and redeeming of the BaasketToken, you can run `npx hardhat deployMintAndRedeem.js`, and follow along with the tx&#39;s on etherscan for the `BasketBroker` address.

If you want to further configure/test and run the lottery portion, execute these commands in order. (It is OK to run `mint.js`, `redeem.js`, and `lotto.js` at any time after the first iterration, assuming the correct assets and allowances are in place.)

- `npx hardhat deployContracts.js` will simply deploy all of the necessary contracts and returns their addresses. It will also generate two ERC20 tokens, and the initial supply is minted to the deployer. (Make sure to update the contract address constants with the freshly deployed contracts in the files below.)
  
- `npx hardhat mint.js` will set the allowances for the underlying ERC20 components and exchange them for BasketTokens.
  
- `npx hardhat redeem.js` will trade the BasketToken back in for the underlying ERC20 components.
  
- Go to [the Chainlink test faucet](https://faucets.chain.link/) in a web browser and send some testnet LINK to your `BasketBroker` contract address to fund the Chainlink Oracle (.01 LINK required per call to the oracle).
  
- `lotto.js` sends some of the underlying ERC20 compenents to a second user so they can mint BasketTokens (there&#39;s no point in a lottery with just one person). It then calls the `imFeelingLucky()` function in `BasketBroker` to execute the lottery.
  
## Deployed Rinkeby Example
  
[Here](https://rinkeby.etherscan.io/address/0x578e3591ffa88ba5c32116924a264bf63414fe12) is an examples of a successful deploy to Rinkeby with example transactions of issuing, redeeming, and lotteries.
