# BasketToken

`BasketToken` is a naive implementation of [Set Protocol&#39;s](https://github.com/SetProtocol/set-protocol-v2) `SetToken` and `BasicIssuanceModule`.

BasketToken allows users to create a new ERC20 token as a &quot;basket&quot; or &quot;set&quot; of underlying ERC20&#39;s. The user decides how many units of the underlying ERC20&#39;s must be transferred into the contract in order to mint a BasketTon.

## Contracts

The protocol consists of 3 contracts:

- `BasketToken.sol` is the ERC20 token, based on Set Protocol&#39;s `SetToken`, this is the architecture for BasketToken, containing the constructor that is interacted with in the next contract.
  
- `BasketCreator.sol` is a factory contract for generating and deploying BasketTokens. New BasketToken creators provide the components (underlying ERC20s), units (how many units of the ERC20s are required per BasketToken), a name for the BasketToken and finally a symbol to the `create()` function to generate a new BasketToken.
  
- `BasketBroker.sol` is the contract for interacting with a specific BasketToken instance. This contract handles the issuing of the BasketToken for underlying ERC20&#39;s as well as redeeming of BasketTokens in exchange for the underlying ERC20&#39;s (This portion of the contract is based on Set Protocol&#39;s [BasicIssuanceModule](https://github.com/SetProtocol/set-protocol-v2/blob/master/contracts/protocol/modules/BasicIssuanceModule.sol). In addition to the swapping in and out of BasketTokens, this contract also handles the lottery and pot fee incorporated with the BasketToken. This contract is specific to each BasketToken. The constructor takes the BasketToken address as a parameter as well [the necessary Chainlink variables](https://docs.chain.link/docs/vrf-contracts/) for the Oracle.
  

## Lottery + Pot Fees

The twist behind this implementation of BasketToken is that when you redeem your BasketToken back for the underlying ERC20 components, 5% of the BasketToken is not burned, but held in reserve for a lottery.

Each time a user mints BasketTokens, a mapping keeps track of how BasketTokens an address holds. The mapping is also reduced as users redeem their BasketTokens. This means user&#39;s who own more BasketTokens are more likely to win the lottery when it is drawn.

Any user may call the `imFeelingLucky()` function in `BasketBroker.sol` to kick off the lottery, however, there is only a 30% chance the lottery takes place. The 30% is calculated by using a random number generated by Chainlink&#39;s [VRFConsumer](https://github.com/daiquilibrium/daiquilibrium-protocol/blob/master/protocol/contracts/lottery/chainlink/VRFConsumerBase.sol). The formula is `(randomNum % 10) + 1` which provides a number between 1-10. If the number is &lt;= 3, the lottery takes places. The user can check if the lottery occured by viewing the Events on Etherscan.

If the lottery takes place, the lottery tickets array is populated based on the amount of BasketTokens per address. The lottery tickets array is then shuffled using Fisher-Yates algorithm based on the same random number used to calculate the lottery chance. The user with their address in the first position of the array after the shuffle, will be transferred the accrued pot fees from prior BasketToken redemption pot fees.

## Deploying with HardHat

In the `scripts` directory there are examples of how to deploy and interact with the contracts via `ethers.js`. All of these examples take place on the Rinkeby testnet, but could be tweaked for mainnet or other testnets. For these examples, it is necessary to have two addresses in the `.env` file and configured in `hardhat.config.js` (they also need to have Rinkeby Ether in order to cover gas of the transactions).

If you simply want to deploy the contracts, and test the issuing and redeeming of the BaasketToken, you can run `deployMintAndRedeem.js`, and follow along with the tx&#39;s on etherscan for the `BasketBroker` address.

If you want to further configure and run the lottery portion, execute these commands in order. (It is OK to run `mint.js`, `redeem.js`, and `lotto.js` at any time after the first iterration, assuming the correct assets and allowances are in place.)

- `deployContracts.js` simply deploys all of the necessary contracts and returns their addresses. It also generates two ERC20 tokens, and their initial supply is minted to the deployer. (Make sure to update the addresses of your contract addresses constants in the files below.)
  
- `mint.js` sets the allowances for the underlying ERC20 components and exchanges them for BasketTokens.
  
- `redeem.js` trades the BasketToken back in for the underlying ERC20 components.
  
- Go to [the Chainlink test faucet](https://faucets.chain.link/) and send some test LINK to your `BasketBroker` contract for the random number functions.
  
- `lotto.js` sends some of the underlying ERC20 compenents to a second user so they can mint BasketTokens (there&#39;s no point in a lottery with just one person). It then calls the `imFeelingLucky()` function in `BasketBroker`.
  
## Deployed Rinkeby Example
  
[Here](https://rinkeby.etherscan.io/address/0x578e3591ffa88ba5c32116924a264bf63414fe12) is an examples of a successful deploy to Rinkeby with example transactions of issuing, redeeming, and lotteries.